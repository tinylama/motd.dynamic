#!/usr/bin/env python3
"""
Modern Dynamic MOTD (Message of the Day) Script
A visually stunning and highly configurable system information display for Linux systems.

Copyright (c) 2015 Mazdak Farrokhzad, Nick Charlton, Dustin Kirkland, Michael Vogt
Updated for Python 3 with modern improvements by Assistant

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
"""

import asyncio
import json
import os
import platform
import re
import socket
import subprocess
import sys
import time
import warnings
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Union

# Suppress deprecation warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

# Third-party imports
try:
    import psutil
    import pyfiglet
    from rich.console import Console
    from rich.table import Table
    from rich.text import Text
    from rich.panel import Panel
    from rich.columns import Columns
    from rich.progress import Progress, SpinnerColumn, TextColumn
    from rich.align import Align
    from rich.layout import Layout
    from rich import box
    import requests
    import distro
except ImportError as e:
    print(f"‚ùå Missing required package: {e}")
    print("üì¶ Install with: pip3 install -r requirements.txt")
    sys.exit(1)

# Configuration class for better organization
@dataclass
class MOTDConfig:
    # Display settings
    line_length: int = 100
    left_col_length: int = 25
    
    # Banner settings
    banner_text: str = "CENTRIL-NAS"
    banner_fonts: List[str] = None
    banner_justify: str = "center"  # left, center, right
    banner_style: str = "bold cyan"
    
    # Color theme (Rich color names)
    color_ok: str = "green"
    color_warn: str = "yellow" 
    color_critical: str = "red"
    color_info: str = "cyan"
    color_header: str = "magenta"
    color_accent: str = "blue"
    
    # Feature toggles
    show_banner: bool = True
    show_quote: bool = True
    show_weather: bool = False  # Requires API key
    show_docker: bool = True
    show_systemd: bool = True
    show_network_speed: bool = True
    show_ssl_certs: bool = True
    
    # Thresholds
    disk_warn_threshold: int = 70
    disk_critical_threshold: int = 85
    memory_warn_threshold: int = 70
    memory_critical_threshold: int = 85
    cpu_warn_threshold: int = 70
    cpu_critical_threshold: int = 85
    
    # External services
    weather_api_key: Optional[str] = None
    weather_city: str = "London"
    
    def __post_init__(self):
        if self.banner_fonts is None:
            self.banner_fonts = ["slant", "3d", "big", "block", "doom", "epic"]

# Global config instance
config = MOTDConfig()

# Console instance for Rich output
console = Console(width=config.line_length)

class SystemInfo:
    """Collects and formats system information."""
    
    @staticmethod
    def get_uptime() -> str:
        """Get system uptime in human readable format."""
        try:
            with open('/proc/uptime', 'r') as f:
                uptime_seconds = float(f.readline().split()[0])
            
            uptime_delta = timedelta(seconds=uptime_seconds)
            days = uptime_delta.days
            hours, remainder = divmod(uptime_delta.seconds, 3600)
            minutes, _ = divmod(remainder, 60)
            
            parts = []
            if days:
                parts.append(f"{days} day{'s' if days != 1 else ''}")
            if hours:
                parts.append(f"{hours} hour{'s' if hours != 1 else ''}")
            if minutes:
                parts.append(f"{minutes} minute{'s' if minutes != 1 else ''}")
                
            return ", ".join(parts) if parts else "Less than a minute"
        except:
            return "Unknown"
    
    @staticmethod
    def get_boot_time() -> str:
        """Get system boot time."""
        try:
            return datetime.fromtimestamp(psutil.boot_time()).strftime('%Y-%m-%d %H:%M:%S')
        except:
            return "Unknown"
    
    @staticmethod
    def get_system_info() -> str:
        """Get system information."""
        try:
            # Use modern distro functions instead of deprecated linux_distribution()
            try:
                dist_name = distro.name(pretty=True)
                dist_version = distro.version()
                dist_info = f"{dist_name} {dist_version}"
            except:
                dist_info = platform.system()
            
            arch = platform.machine()
            kernel = platform.release()
            
            return f"{dist_info}, {kernel}, {arch}"
        except:
            return "Unknown"
    
    @staticmethod
    def get_cpu_info() -> Tuple[str, str]:
        """Get CPU information and current usage."""
        try:
            # Get CPU model
            with open('/proc/cpuinfo', 'r') as f:
                for line in f:
                    if line.startswith('model name'):
                        cpu_model = line.split(':')[1].strip()
                        break
                else:
                    cpu_model = "Unknown CPU"
            
            # Get CPU usage
            cpu_percent = psutil.cpu_percent(interval=1)
            cpu_count = psutil.cpu_count()
            
            cpu_info = f"{cpu_model} ({cpu_count} cores)"
            cpu_usage = f"{cpu_percent:.1f}%"
            
            return cpu_info, cpu_usage
        except:
            return "Unknown", "Unknown"
    
    @staticmethod
    def get_memory_info() -> Tuple[str, str]:
        """Get memory information."""
        try:
            mem = psutil.virtual_memory()
            total_gb = mem.total / (1024**3)
            used_gb = mem.used / (1024**3)
            available_gb = mem.available / (1024**3)
            
            memory_info = f"{total_gb:.1f} GB total"
            memory_usage = f"{mem.percent:.1f}% ({used_gb:.1f}G used, {available_gb:.1f}G free)"
            
            return memory_info, memory_usage
        except:
            return "Unknown", "Unknown"
    
    @staticmethod
    def get_disk_info() -> List[Tuple[str, str, float]]:
        """Get disk usage information for important mount points only."""
        disk_info = []
        important_mounts = {'/', '/home', '/var', '/tmp', '/boot', '/boot/efi'}
        
        try:
            partitions = psutil.disk_partitions()
            for partition in partitions:
                mount_point = partition.mountpoint
                
                # Skip snap mounts and other unimportant ones
                if any(skip in mount_point for skip in ['/snap/', '/var/lib/', '/var/games', '/var/mail', '/var/spool', '/var/www', '/usr/local']):
                    continue
                
                # Only include important mounts or those with significant usage
                try:
                    usage = psutil.disk_usage(mount_point)
                    percent = (usage.used / usage.total) * 100
                    
                    # Include if it's an important mount or has >5% usage
                    if mount_point in important_mounts or percent > 5:
                        total_gb = usage.total / (1024**3)
                        used_gb = usage.used / (1024**3)
                        free_gb = usage.free / (1024**3)
                        
                        usage_str = f"{percent:.1f}% ({used_gb:.1f}G used, {free_gb:.1f}G free of {total_gb:.1f}G)"
                        disk_info.append((mount_point, usage_str, percent))
                except:
                    continue
        except:
            pass
        
        # Sort by usage percentage (highest first)
        disk_info.sort(key=lambda x: x[2], reverse=True)
        return disk_info
    
    @staticmethod
    def get_network_info() -> Dict[str, str]:
        """Get network interface information."""
        network_info = {}
        try:
            interfaces = psutil.net_if_addrs()
            for interface, addrs in interfaces.items():
                if interface == 'lo':  # Skip loopback
                    continue
                    
                for addr in addrs:
                    if addr.family == socket.AF_INET:  # IPv4
                        network_info[f"{interface} (IPv4)"] = addr.address
                    elif addr.family == socket.AF_INET6:  # IPv6
                        # Show only the first part of IPv6 for brevity
                        ipv6_short = addr.address.split('%')[0][:20] + "..."
                        network_info[f"{interface} (IPv6)"] = ipv6_short
        except:
            pass
        
        return network_info
    
    @staticmethod
    def get_public_ip() -> str:
        """Get public IP address."""
        try:
            response = requests.get('https://api.ipify.org', timeout=3)
            return response.text.strip()
        except:
            return "Unknown"
    
    @staticmethod
    def get_logged_users() -> str:
        """Get currently logged in users."""
        try:
            users = psutil.users()
            user_counts = defaultdict(int)
            for user in users:
                user_counts[user.name] += 1
            
            if not user_counts:
                return "No active sessions"
            
            user_list = [f"{user} ({count})" for user, count in user_counts.items()]
            return ", ".join(user_list)
        except:
            return "Unknown"
    
    @staticmethod
    def get_load_average() -> str:
        """Get system load average."""
        try:
            load1, load5, load15 = os.getloadavg()
            return f"{load1:.2f}, {load5:.2f}, {load15:.2f}"
        except:
            return "Unknown"
    
    @staticmethod
    def get_processes_count() -> str:
        """Get process count."""
        try:
            total_processes = len(psutil.pids())
            return str(total_processes)
        except:
            return "Unknown"

class EnhancedFeatures:
    """Additional modern features."""
    
    @staticmethod
    def get_docker_info() -> Optional[Dict[str, str]]:
        """Get Docker container information."""
        try:
            result = subprocess.run(['docker', 'ps', '--format', 'table {{.Names}}\t{{.Status}}'], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')[1:]  # Skip header
                if lines and lines[0]:  # Check if there are any containers
                    running = len([l for l in lines if 'Up' in l])
                    total = len(lines)
                    return {
                        "containers": f"{running}/{total} running",
                        "details": lines[:3]  # Show first 3 containers
                    }
        except:
            pass
        return None
    
    @staticmethod
    def get_systemd_failed() -> Optional[List[str]]:
        """Get failed systemd services."""
        try:
            result = subprocess.run(['systemctl', '--failed', '--no-pager', '--plain'], 
                                  capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                lines = result.stdout.strip().split('\n')
                failed_services = []
                for line in lines:
                    if '.service' in line and 'failed' in line:
                        service_name = line.split()[0]
                        failed_services.append(service_name)
                return failed_services[:5]  # Limit to 5 services
        except:
            pass
        return None
    
    @staticmethod
    def get_package_updates() -> Optional[int]:
        """Get available package updates."""
        try:
            # For Ubuntu/Debian
            if Path('/usr/bin/apt').exists():
                result = subprocess.run(['apt', 'list', '--upgradable'], 
                                      capture_output=True, text=True, timeout=10)
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    # Filter out the header line
                    updates = [l for l in lines if '/' in l and 'upgradable' in l]
                    return len(updates)
            
            # For RHEL/CentOS/Fedora
            elif Path('/usr/bin/dnf').exists():
                result = subprocess.run(['dnf', 'check-update', '--quiet'], 
                                      capture_output=True, text=True, timeout=10)
                if result.returncode == 100:  # dnf returns 100 when updates are available
                    lines = result.stdout.strip().split('\n')
                    return len([l for l in lines if l and not l.startswith('Last metadata')])
        except:
            pass
        return None
    
    @staticmethod
    def get_ssl_cert_info() -> List[Tuple[str, str, int]]:
        """Get SSL certificate expiration info for common services."""
        cert_info = []
        common_ports = [443, 8443, 9443]  # Common HTTPS ports
        
        try:
            # Get hostname
            hostname = socket.gethostname()
            
            for port in common_ports:
                try:
                    import ssl
                    context = ssl.create_default_context()
                    with socket.create_connection((hostname, port), timeout=3) as sock:
                        with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                            cert = ssock.getpeercert()
                            if cert:
                                expiry_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                                days_until_expiry = (expiry_date - datetime.now()).days
                                cert_info.append((f"{hostname}:{port}", expiry_date.strftime('%Y-%m-%d'), days_until_expiry))
                except:
                    continue
        except:
            pass
        
        return cert_info

class MOTDRenderer:
    """Handles the visual rendering of MOTD information."""
    
    def __init__(self):
        self.console = console
    
    def create_banner(self) -> Panel:
        """Create the main banner."""
        if not config.show_banner:
            return None
            
        try:
            import random
            font = random.choice(config.banner_fonts)
            fig = pyfiglet.Figlet(font=font)
            banner_text = fig.renderText(config.banner_text)
            
            # Create styled text
            styled_banner = Text(banner_text, style=config.banner_style)
            
            return Panel(
                Align.center(styled_banner),
                box=box.DOUBLE_EDGE,
                style=config.color_accent,
                title="üñ•Ô∏è  System Banner",
                title_align="center"
            )
        except:
            # Fallback if figlet fails
            styled_text = Text(config.banner_text, style=f"bold {config.color_accent}")
            return Panel(
                Align.center(styled_text),
                box=box.ROUNDED,
                style=config.color_info
            )
    
    def create_system_info_table(self) -> Table:
        """Create system information table."""
        table = Table(box=box.ROUNDED, show_header=False, padding=(0, 1))
        table.add_column("Property", style=config.color_info, width=config.left_col_length)
        table.add_column("Value", style="white")
        
        # Collect system info
        uptime = SystemInfo.get_uptime()
        boot_time = SystemInfo.get_boot_time()
        system_info = SystemInfo.get_system_info()
        cpu_info, cpu_usage = SystemInfo.get_cpu_info()
        memory_info, memory_usage = SystemInfo.get_memory_info()
        load_avg = SystemInfo.get_load_average()
        processes = SystemInfo.get_processes_count()
        users = SystemInfo.get_logged_users()
        
        # Determine CPU color
        try:
            cpu_percent = float(cpu_usage.replace('%', ''))
            if cpu_percent > config.cpu_critical_threshold:
                cpu_color = config.color_critical
            elif cpu_percent > config.cpu_warn_threshold:
                cpu_color = config.color_warn
            else:
                cpu_color = config.color_ok
        except:
            cpu_color = "white"
        
        # Determine memory color
        try:
            mem_percent = float(memory_usage.split('%')[0])
            if mem_percent > config.memory_critical_threshold:
                mem_color = config.color_critical
            elif mem_percent > config.memory_warn_threshold:
                mem_color = config.color_warn
            else:
                mem_color = config.color_ok
        except:
            mem_color = "white"
        
        # Add rows
        table.add_row("üïê Uptime", uptime)
        table.add_row("üöÄ Boot Time", boot_time)
        table.add_row("üíª System", system_info)
        table.add_row("üîß CPU", cpu_info)
        table.add_row("üìä CPU Usage", Text(cpu_usage, style=cpu_color))
        table.add_row("üß† Memory", memory_info)
        table.add_row("üìà Memory Usage", Text(memory_usage, style=mem_color))
        table.add_row("‚öñÔ∏è  Load Average", load_avg)
        table.add_row("üîÑ Processes", processes)
        table.add_row("üë• Users", users)
        
        return table
    
    def create_disk_info_table(self) -> Table:
        """Create disk usage table."""
        table = Table(box=box.ROUNDED, show_header=False, padding=(0, 1))
        table.add_column("Mount Point", style=config.color_info, width=config.left_col_length)
        table.add_column("Usage", style="white")
        
        disk_info = SystemInfo.get_disk_info()
        
        for mount_point, usage_str, percent in disk_info:
            # Determine color based on usage
            if percent > config.disk_critical_threshold:
                color = config.color_critical
            elif percent > config.disk_warn_threshold:
                color = config.color_warn
            else:
                color = config.color_ok
            
            # Add emoji for common mount points
            emoji = "üíæ"
            if mount_point == "/":
                emoji = "üè†"
            elif "home" in mount_point:
                emoji = "üè°"
            elif "var" in mount_point:
                emoji = "üìÅ"
            elif "tmp" in mount_point:
                emoji = "üóëÔ∏è"
            elif "boot" in mount_point:
                emoji = "üöÄ"
            
            table.add_row(f"{emoji} {mount_point}", Text(usage_str, style=color))
        
        return table
    
    def create_network_info_table(self) -> Table:
        """Create network information table."""
        table = Table(box=box.ROUNDED, show_header=False, padding=(0, 1))
        table.add_column("Interface", style=config.color_info, width=config.left_col_length)
        table.add_column("Address", style="white")
        
        network_info = SystemInfo.get_network_info()
        public_ip = SystemInfo.get_public_ip()
        
        # Add public IP first
        table.add_row("üåê Public IP", public_ip)
        
        # Add network interfaces
        for interface, address in network_info.items():
            emoji = "üîó"
            if "wlan" in interface.lower() or "wifi" in interface.lower():
                emoji = "üì°"
            elif "eth" in interface.lower() or "en" in interface.lower():
                emoji = "üåê"
            elif "docker" in interface.lower():
                emoji = "üê≥"
            
            table.add_row(f"{emoji} {interface}", address)
        
        return table
    
    def create_enhanced_features_table(self) -> Optional[Table]:
        """Create table for enhanced features."""
        table = Table(box=box.ROUNDED, show_header=False, padding=(0, 1))
        table.add_column("Feature", style=config.color_info, width=config.left_col_length)
        table.add_column("Status", style="white")
        
        rows_added = 0
        
        # Docker info
        if config.show_docker:
            docker_info = EnhancedFeatures.get_docker_info()
            if docker_info:
                table.add_row("üê≥ Docker", docker_info["containers"])
                rows_added += 1
        
        # Package updates
        updates = EnhancedFeatures.get_package_updates()
        if updates is not None:
            color = config.color_warn if updates > 0 else config.color_ok
            status = f"{updates} available" if updates > 0 else "Up to date"
            table.add_row("üì¶ Updates", Text(status, style=color))
            rows_added += 1
        
        # Failed systemd services
        if config.show_systemd:
            failed_services = EnhancedFeatures.get_systemd_failed()
            if failed_services is not None:
                if failed_services:
                    color = config.color_critical
                    status = f"{len(failed_services)} failed: {', '.join(failed_services[:2])}"
                else:
                    color = config.color_ok
                    status = "All services OK"
                table.add_row("‚öôÔ∏è  Services", Text(status, style=color))
                rows_added += 1
        
        # SSL certificates
        if config.show_ssl_certs:
            ssl_certs = EnhancedFeatures.get_ssl_cert_info()
            for cert_name, expiry_date, days_left in ssl_certs:
                if days_left < 30:
                    color = config.color_critical
                elif days_left < 60:
                    color = config.color_warn
                else:
                    color = config.color_ok
                
                table.add_row(f"üîí SSL {cert_name}", Text(f"Expires in {days_left} days", style=color))
                rows_added += 1
        
        return table if rows_added > 0 else None
    
    def create_quote_panel(self) -> Optional[Panel]:
        """Create an inspirational quote panel."""
        if not config.show_quote:
            return None
            
        quotes = [
            "The best way to predict the future is to invent it. - Alan Kay",
            "Code is like humor. When you have to explain it, it's bad. - Cory House",
            "Programs must be written for people to read, and only incidentally for machines to execute. - Harold Abelson",
            "The computer was born to solve problems that did not exist before. - Bill Gates",
            "Software is a great combination between artistry and engineering. - Bill Gates",
            "First, solve the problem. Then, write the code. - John Johnson",
            "Experience is the name everyone gives to their mistakes. - Oscar Wilde",
            "In order to be irreplaceable, one must always be different. - Coco Chanel",
            "Java is to JavaScript what car is to Carpet. - Chris Heilmann",
            "Knowledge is power. - Francis Bacon"
        ]
        
        import random
        quote = random.choice(quotes)
        
        return Panel(
            Align.center(Text(quote, style="italic cyan")),
            box=box.ROUNDED,
            title="üí≠ Quote of the Day",
            title_align="center",
            style="dim"
        )

def main():
    """Main function to display the MOTD."""
    try:
        renderer = MOTDRenderer()
        console = Console(width=config.line_length)
        
        # Create components
        components = []
        
        # Banner
        banner = renderer.create_banner()
        if banner:
            components.append(banner)
        
        # System info table
        sys_table = renderer.create_system_info_table()
        sys_panel = Panel(sys_table, title="üñ•Ô∏è  System Information", 
                         title_align="left", box=box.ROUNDED)
        components.append(sys_panel)
        
        # Disk info table
        disk_table = renderer.create_disk_info_table()
        if disk_table.rows:
            disk_panel = Panel(disk_table, title="üíæ Disk Usage", 
                              title_align="left", box=box.ROUNDED)
            components.append(disk_panel)
        
        # Network info table  
        net_table = renderer.create_network_info_table()
        if net_table.rows:
            net_panel = Panel(net_table, title="üåê Network Information", 
                             title_align="left", box=box.ROUNDED)
            components.append(net_panel)
        
        # Enhanced features table
        enhanced_table = renderer.create_enhanced_features_table()
        if enhanced_table and enhanced_table.rows:
            enhanced_panel = Panel(enhanced_table, title="üöÄ Enhanced Features", 
                                  title_align="left", box=box.ROUNDED)
            components.append(enhanced_panel)
        
        # Quote panel
        quote_panel = renderer.create_quote_panel()
        if quote_panel:
            components.append(quote_panel)
        
        # Print all components
        for component in components:
            console.print(component)
            console.print()  # Add spacing
        
        # Footer
        footer_text = Text()
        footer_text.append("Generated on ", style="dim")
        footer_text.append(datetime.now().strftime("%Y-%m-%d %H:%M:%S"), style="bold cyan")
        footer_text.append(" | ", style="dim")
        footer_text.append("Modern MOTD v2.0", style="bold magenta")
        
        console.print(Align.center(footer_text))
        console.print()
        
    except KeyboardInterrupt:
        console.print("\nüëã MOTD interrupted by user", style="yellow")
        sys.exit(0)
    except Exception as e:
        console.print(f"\n‚ùå Error generating MOTD: {e}", style="red")
        sys.exit(1)

if __name__ == "__main__":
    main()